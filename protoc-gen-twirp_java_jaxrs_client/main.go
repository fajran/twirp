// Copyright 2018 Twitch Interactive, Inc.  All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License"). You may not
// use this file except in compliance with the License. A copy of the License is
// located at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// or in the "license" file accompanying this file. This file is distributed on
// an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
// express or implied. See the License for the specific language governing
// permissions and limitations under the License.

package main

import (
	"bytes"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	plugin "github.com/golang/protobuf/protoc-gen-go/plugin"
	"github.com/twitchtv/twirp/internal/gen"
	"github.com/twitchtv/twirp/internal/gen/stringutils"
	"github.com/twitchtv/twirp/internal/gen/typemap"
)

func main() {
	versionFlag := flag.Bool("version", false, "print version and exit")
	flag.Parse()
	if *versionFlag {
		fmt.Println(gen.Version)
		os.Exit(0)
	}

	g := newGenerator()
	gen.Main(g)
}

func newGenerator() *generator {
	return &generator{output: new(bytes.Buffer)}
}

type generator struct {
	reg    *typemap.Registry
	output *bytes.Buffer
}

func (g *generator) Generate(in *plugin.CodeGeneratorRequest) *plugin.CodeGeneratorResponse {
	genFiles := gen.FilesToGenerate(in)
	g.reg = typemap.New(in.ProtoFile)

	resp := new(plugin.CodeGeneratorResponse)
	for _, file := range genFiles {
		outerClass := getOuterClass(file)
		for _, service := range file.Service {
			// TODO generate service interface
			respFile := g.generateClientFile(file, service, outerClass)
			if respFile != nil {
				resp.File = append(resp.File, respFile)
			}
		}
	}

	return resp
}

func (g *generator) generateClientFile(file *descriptor.FileDescriptorProto, service *descriptor.ServiceDescriptorProto, outerClass string) *plugin.CodeGeneratorResponse_File {
	pkg := getJavaPackage(file)

	g.P(`// Code generated by protoc-gen-twirp_java_jaxrs_client `, gen.Version, `, DO NOT EDIT.`)
	g.P(`// source: `, file.GetName())
	g.P()
	g.P(`package `, pkg, `;`)
	g.P()
	g.P(`import java.io.InputStream;`)
	g.P(`import java.util.function.Function;`)
	g.P(`import javax.ws.rs.client.Entity;`)
	g.P(`import javax.ws.rs.client.WebTarget;`)
	g.P(`import javax.ws.rs.core.Response;`)
	g.P(`import javax.ws.rs.core.StreamingOutput;`)
	g.P(`import com.google.protobuf.MessageLite;`)
	g.P()

	comments, err := g.reg.ServiceComments(file, service)
	if err == nil && comments.Leading != "" {
		g.P(`/**`)
		g.printComments(comments, ` * `)
		g.P(` */`)
	}

	className := javaClassName(outerClass, service)

	path := fullServiceName(file, service)
	g.P(`public class `, className, ` {`)
	g.P(`  private static final String PATH = "/twirp/`, path, `";`)
	g.P(`  private final WebTarget target;`)
	g.P()
	g.P(`  public `, className, `(WebTarget target) {`)
	g.P(`    this.target = target;`)
	g.P(`  }`)
	g.P()
	g.P(`  private <T> T _parseSafely(InputStream input, FunctionE<InputStream, T> fn) {`)
	g.P(`    try {`)
	g.P(`      return fn.apply(input);`)
	g.P(`    } catch (Exception e) {`)
	g.P(`      throw new RuntimeException(e);`)
	g.P(`    }`)
	g.P(`  }`)
	g.P()
	g.P(`  @FunctionalInterface`)
	g.P(`  interface FunctionE<A, B> {`)
	g.P(`    B apply(A input) throws Exception;`)
	g.P(`  }`)
	g.P()
	g.P(`  private <R> R _call(String path, MessageLite request, Function<InputStream, R> parser) {`)
	g.P(`    Response response = target.path(path)`)
	g.P(`        .request("application/protobuf")`)
	g.P(`        .post(Entity.entity((StreamingOutput) request::writeTo, "application/protobuf"));`)
	g.P(`    InputStream body = response.readEntity(InputStream.class);`)
	g.P(`    return parser.apply(body);`)
	g.P(`  }`)

	for _, method := range service.Method {
		inputType := getType(outerClass, method.GetInputType())
		outputType := getType(outerClass, method.GetOutputType())
		methName := methodName(method) // TODO
		methodPath := method.GetName()

		g.P()
		comments, err := g.reg.MethodComments(file, service, method)
		if err == nil && comments.Leading != "" {
			g.P(`  /**`)
			g.printComments(comments, `   * `)
			g.P(`   */`)
		}
		g.P(`  public `, outputType, ` `, methName, `(`, inputType, ` request) {`)
		g.P(`    Function<InputStream, `, outputType, `> parser =`)
		g.P(`        (input) -> _parseSafely(input, `, outputType, `::parseFrom);`)
		g.P(`    return _call(PATH + "/`, methodPath, `", request, parser);`)
		g.P(`  }`)
	}
	g.P(`}`)

	resp := new(plugin.CodeGeneratorResponse_File)
	resp.Name = proto.String(javaFileName(pkg, outerClass, service))
	resp.Content = proto.String(g.output.String())
	g.output.Reset()

	return resp
}

func (g *generator) P(args ...string) {
	for _, v := range args {
		g.output.WriteString(v)
	}
	g.output.WriteByte('\n')
}

func (g *generator) printComments(comments typemap.DefinitionComments, prefix string) {
	text := strings.TrimSuffix(comments.Leading, "\n")
	for _, line := range strings.Split(text, "\n") {
		g.P(prefix, strings.TrimPrefix(line, " "))
	}
}

func serviceName(service *descriptor.ServiceDescriptorProto) string {
	return stringutils.CamelCase(service.GetName())
}

func fullServiceName(file *descriptor.FileDescriptorProto, service *descriptor.ServiceDescriptorProto) string {
	name := serviceName(service)
	if pkg := file.GetPackage(); pkg != "" {
		name = pkg + "." + name
	}
	return name
}

func methodName(method *descriptor.MethodDescriptorProto) string {
	name := stringutils.CamelCase(method.GetName())
	return strings.ToLower(string(name[0])) + name[1:len(name)]
}

func getProtoName(file *descriptor.FileDescriptorProto) string {
	name := file.GetName()
	ext := filepath.Ext(name)
	if ext == ".proto" || ext == ".protodevel" {
		name = name[0 : len(name)-len(ext)]
	}
	return name
}
func getProtoClass(file *descriptor.FileDescriptorProto) string {
	name := getProtoName(file)
	return strings.Title(name)
}

func serviceClassName(file *descriptor.FileDescriptorProto, service *descriptor.ServiceDescriptorProto) string {
	return fmt.Sprintf("%s.%s", getProtoClass(file), serviceName(service))
}

func javaClassName(outerClass string, service *descriptor.ServiceDescriptorProto) string {
	return fmt.Sprintf("%s_%sClient", outerClass, serviceName(service))
}

func getJavaPackage(file *descriptor.FileDescriptorProto) string {
	pkg := file.Options.GetJavaPackage()
	if pkg != "" {
		return pkg
	}
	return file.GetPackage()
}

func javaFileName(javaPackage, outerClass string, service *descriptor.ServiceDescriptorProto) string {
	dir := strings.Replace(javaPackage, ".", "/", -1)
	fname := javaClassName(outerClass, service)
	return fmt.Sprintf("%s/%s.java", dir, fname)
}

func getType(outerClass, typeName string) string {
	return fmt.Sprintf("%s.%s", outerClass, stripPackage(typeName))
}

func stripPackage(str string) string {
	p := strings.LastIndex(str, ".")
	return str[p+1 : len(str)]
}

func getOuterClass(file *descriptor.FileDescriptorProto) string {
	name := file.Options.GetJavaOuterClassname()
	if name != "" {
		return name
	}

	name = stringutils.CamelCase(getProtoName(file))
	outer := name + "OuterClass"
	for _, desc := range file.GetMessageType() {
		if strings.Title(desc.GetName()) == name {
			return outer
		}
	}

	for _, desc := range file.GetService() {
		if strings.Title(desc.GetName()) == name {
			return outer
		}
	}

	for _, desc := range file.GetEnumType() {
		if strings.Title(desc.GetName()) == name {
			return outer
		}
	}

	return name
}
